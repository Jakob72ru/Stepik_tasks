# Класс FieldTracker
Реализуйте класс `FieldTracker`, наследники которого получают возможность отслеживать состояние определенных атрибутов своих экземпляров класса. Дочерние классы должны наследовать четыре метода экземпляра:

`base()` — метод, принимающий в качестве аргумента имя атрибута и возвращающий либо текущее значение этого атрибута, либо исходное (указанное при определении) значение этого атрибута, если оно было изменено

`has_changed()` — метод, принимающий в качестве аргумента имя атрибута и возвращающий True, если значение этого атрибута было изменено хотя бы раз, или False в противном случае

`changed()` — метод, возвращающий словарь, в котором ключами являются имена атрибутов, которые изменяли свои значения, а значениями — их исходные значения

`save()` — метод, сбрасывающий отслеживание. После вызова метода считается, что все атрибуты ранее не изменяли свои значения, а их текущие значения считаются исходными
Гарантируется, что наследники класса `FieldTracker`:

всегда имеют атрибут класса `fields`, содержащий кортеж с атрибутами, которые необходимо отслеживать
в своем инициализаторе всегда вызывают инициализатор класса `FieldTracker` после установки первичных значений отслеживаемым атрибутам

**Примечание 1.** Будем считать, что атрибут изменяет свое значение только в том случае, если устанавливаемое значение отличается от текущего.

**Примечание 2.** Реализация класса `FieldTracker` может быть произвольной, то есть требований к наличию определенных атрибутов нет.

**Примечание 3.** Дополнительная проверка данных на корректность в методах не требуется. Гарантируется, что реализованный класс используется только с корректными данными.

Ссылка на задачу на площадке - https://stepik.org/lesson/798678/step/21?unit=801641

## Решение
```
from copy import copy

class FieldTracker:
    fields = ()
    counter = 0
    def __init__(self, *args, **kwargs):
        self.attrs = copy(self.__dict__)

    def __setattr__(self, attr, value):
        self.__dict__[attr] = value

        if self.__class__.counter >= len(self.__class__.fields):
            if attr not in self.attrs:
                self.attrs[attr] = value
        self.__class__.counter += 1

    def base(self, attrname):
        return self.attrs[attrname]

    def has_changed(self, attrname):
        return self.__dict__[attrname] != self.attrs[attrname]

    def changed(self):
        d = {key: value for key, value in self.attrs.items() if self.has_changed(key)}
        return d

    def save(self):
        self.attrs = copy(self.__dict__)
        del self.attrs['attrs']
```